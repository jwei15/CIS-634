%% ---------------------------------------------------
%% Notice that we use the "report" class instead of "article"
%% ---------------------------------------------------
\documentclass{report}

\title{Project 7}
\author{\textbf{Jinhao Wei}}
\date{\textbf{5 March 2019}}

%% ---------------------------------------------------
%% CSBDformat specifies the format of our reports
%% ---------------------------------------------------
\usepackage{634format}

%% ---------------------------------------------------
%% enumerate 
%% ---------------------------------------------------
\usepackage{enumerate}

%% ---------------------------------------------------
%% listings is used for including our source code in reports
%% ---------------------------------------------------
\usepackage{listings}
\usepackage{textcomp}

%% ---------------------------------------------------
%% Packages for math environments
%% ---------------------------------------------------
\usepackage{amsmath}

%% ---------------------------------------------------
%% Packages for URLs and hotlinks in the table of contents
%% and symbolic cross references using \ref
%% ---------------------------------------------------
\usepackage{hyperref}

%% ---------------------------------------------------
%% Packages for using HOL-generated macros and displays
%% ---------------------------------------------------
\usepackage{holtex}
\usepackage{holtexbasic}
\input{commands}

\begin{document}


\input{../HOL/HOLReports/HOLexType}
\input{../HOL/HOLReports/HOLnexp}

%% --------------------------------------------------- the listings
%% parameter "language" is set to "ML"
%% ---------------------------------------------------
\lstset{language=ML,breaklines}


\maketitle{}

\begin{abstract}
  This report is basically a summary on my attempts on Project 7, which includes proof by induction, function definition and datatype definiton. This report provides my solution on \emph{exercise 11.6.1}, \emph{11.6.2} and \emph{11.6.3}. In addition, I had fine printed the corresponding datatypes and proofs and put the reports in \emph{../HOL/HOLReports/exTypeReport.pdf} and \emph{../HOL/HOLReports/nexpReport.pdf}.
\end{abstract}

\begin{acknowledgments}
  This project follows the format and structure of \emph{sampleTheory} provided by Professor Shiu-Kai Chin. To make it more accurate, this project mostly followed the format of one of my previous projects, which is project 5, and project 5 followed the sturcture of Professor Shiu-Kai Chin's \emph{sampleTheory} project.
\end{acknowledgments}

\tableofcontents{}

\chapter{Executive Summary}
\label{cha:executive-summary}

\textbf{All requirements for this project are satisfied}.  In
particular, we defined all the datatypes and proved all the theorems in this project, pretty printed the HOL theories,
and made use of the \emph{EmitTeX} structure to typeset HOL theorems
in this report.


We gave definitions for the following functions or datatypes
\begin{quote}
  \HOLexTypeDefinitions
  \HOLnexpDatatypes
  \HOLnexpDefinitions
\end{quote}

and the following theorems are proved
\begin{quote}
  \HOLexTypeTheorems
  \HOLnexpTheorems
\end{quote}

\begin{description}
\item [Reproducibility in ML and \LaTeX]\ \\
All ML and \LaTeX{} source files compile well on the environment provided by this course.
\end{description}

\chapter{Exercise 11.6.1}
\label{cha:e1161}

\section{Problem Statement}
\label{sec:e1161ps}
In this exercise, we will define a function named \emph{APP}, according to the following formula \HOLexTypeDefinitionsAPPXXdef and prove the theorem 
\HOLexTypeTheoremsLENGTHXXAPP

Before we go through the following sections, we will need to print 
\begin{lstlisting}[frame=trBL]
open HolKernel Parse boolLib bossLib;
open arithmeticTheory listTheory;
\end{lstlisting}
in HOL session.
\section{Definition of \emph{APP}}
\label{sec:e1161definition}
\subsection{Code for defining \emph{APP}}
\label{subsec:e1161code}
We used the following code to define \emph{APP}
\begin{lstlisting}[frame=trBL]
val APP_def =
Define
`(APP [] (l:'a list) = l) /\
(APP (h::(l1:'a list)) (l2:'a list) = h::(APP l1 l2))`;

\end{lstlisting}

\subsection{Session Transcript}
\label{subsec:e1161st}
If we send the above code to HOL, we will see the transcript as below:
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
 
> # # # Definition has been stored under "APP_def"
val APP_def =
   |- (!(l :'a list). APP ([] :'a list) l = l) /\
   !(h :'a) (l1 :'a list) (l2 :'a list). APP (h::l1) l2 = h::APP l1 l2:
   thm
\end{verbatim}
\end{scriptsize}
\end{session}

\section{Proof for \emph{LENGTH_APP}}
\label{sec:e1161proof}
\subsection{Code for Proving \emph{LENGTH_APP}}
\label{subsec:e1161codeforproof}
\begin{lstlisting}[frame = trBL] 
val LENGTH_APP =
TAC_PROOF(
([], ``!(l1:'a list)(l2:'a list). LENGTH (APP l1 l2) = LENGTH l1 + LENGTH l2``),
(Induct_on `l1` THEN
ASM_REWRITE_TAC [APP_def, LENGTH, ADD_CLAUSES] THEN
ASM_REWRITE_TAC [APP_def, LENGTH, ADD_CLAUSES]
)
)
\end{lstlisting}

\subsection{Session Transcript}
The above code will give us transcript as below:
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
 
> # # # # # # # val LENGTH_APP =
   |- !(l1 :'a list) (l2 :'a list).
     LENGTH (APP l1 l2) = LENGTH l1 + LENGTH l2:
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}


\chapter{Exercise 11.6.2}

\section{Problem Statement}
In this exercise, we defined a function \emph{Map}, using the following formula

\HOLexTypeDefinitionsMapXXdef

 and proved the theorem \emph{Map_APP}:

\HOLexTypeTheoremsMapXXAPP 

Before we go through the following sections, we will need to print 
\begin{lstlisting}[frame=trBL]
open HolKernel Parse boolLib bossLib;
open arithmeticTheory listTheory;
\end{lstlisting}
in HOL session.

\section{Definition of \emph{Map}}

\subsection{Code for Defining \emph{Map}}
We use the following code to define \emph{Map}
\begin{lstlisting}[frame=trBL]
val Map_def =
Define
`(Map f [] = []) /\
 (Map f ((h:'a)::(l:'a list)) = (f h)::(Map f l))`;
\end{lstlisting}

\subsection{Session Transcript}
\label{sec:session-transcript}
The above code will give us transcript as below:
\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

> # # # <<HOL message: inventing new type variable names: 'b>>
Definition has been stored under "Map_def"
val Map_def =
   |- (!(f :'a -> 'b). Map f ([] :'a list) = ([] :'b list)) /\
   !(f :'a -> 'b) (h :'a) (l :'a list). Map f (h::l) = f h::Map f l:
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}

\section{Proof of  \emph{Map_APP}}

\subsection{Code for Proving \emph{Map_APP}}
We will use the following code to prove \emph{Map_APP}.
\begin{lstlisting}[frame=trBL]
val Map_APP =
TAC_PROOF(
([], ``Map f (APP (l1:'a list)(l2:'a list)) = APP (Map f l1) (Map f l2)``),
(Induct_on`l1` THEN
 ASM_REWRITE_TAC [Map_def, APP_def] THEN
 ASM_REWRITE_TAC [APP_def, Map_def]
));
\end{lstlisting}

\subsection{Session Transcript}
The above code will give us transcript as below:
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

> # # # # # # <<HOL message: inventing new type variable names: 'b>>
val Map_APP =
   |- Map (f :'a -> 'b) (APP (l1 :'a list) (l2 :'a list)) =
   APP (Map f l1) (Map f l2):
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}


\chapter{Exercise 11.6.3}


\section{Problem Statement}
In this exercise, we will define our datatype \emph{nexp}:
\begin{quote}
\HOLnexpDatatypesnexp
\end{quote}
 and its semantic \emph{nexpVal}

\begin{quote}
\HOLnexpDefinitions
\end{quote}
 then we will prove several theorems concerning the datatype, including
\begin{quote}
\HOLnexpTheorems
\end{quote}

Before we go through the following sections, we will need to enter the code below in HOL window.
\begin{lstlisting}[frame=trBL]
open HolKernel Parse boolLib bossLib;
open TypeBase boolTheory arithmeticTheory
\end{lstlisting}

\section{Definition of \emph{nexp}}

\subsection{Code for Defining \emph{nexp}}

\begin{lstlisting}[frame=trBL]
val _ = Datatype
`nexp = Num num | Add nexp nexp | Sub nexp nexp | Mult nexp nexp`;
\end{lstlisting}

\subsection{Session Transcript}
\label{sec:session-transcript}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}
 
> # <<HOL message: Defined type: "nexp">>
\end{verbatim}
  \end{scriptsize}
\end{session}

\section{Definition of \emph{nexpVal}}

\subsection{Code for Defining \emph{nexpVal}}
\begin{lstlisting}[frame=trBL]
val nexpVal_def =
Define
`
(nexpVal (Num num) = num)/\
(nexpVal (Add f1 f2) = (nexpVal f1) + (nexpVal  f2))/\
(nexpVal (Sub f1 f2) = (nexpVal f1) - (nexpVal  f2))/\
(nexpVal (Mult f1 f2) = (nexpVal f1) * (nexpVal  f2))
`
\end{lstlisting}

\subsection{Session Transcript}
\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

> # # # # # # # Definition has been stored under "nexpVal_def"
val nexpVal_def =
   |- (!(num :num). nexpVal (Num num) = num) /\
   (!(f1 :nexp) (f2 :nexp).
      nexpVal (Add f1 f2) = nexpVal f1 + nexpVal f2) /\
   (!(f1 :nexp) (f2 :nexp).
      nexpVal (Sub f1 f2) = nexpVal f1 - nexpVal f2) /\
   !(f1 :nexp) (f2 :nexp).
     nexpVal (Mult f1 f2) = nexpVal f1 * nexpVal f2:
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}



\section{Proof of \emph{Add_0}}


\subsection{Code for Proving \emph{Add_0}}
\begin{lstlisting}[frame=trBL]
val Add_0 =
TAC_PROOF(
([], ``!f.nexpVal (Add (Num 0) f) = nexpVal f``),
Induct_on `f` THEN
ASM_REWRITE_TAC [ADD] THEN
REWRITE_TAC [nexpVal_def] THEN
REWRITE_TAC [ADD] THEN
REPEAT (PROVE_TAC [ADD, SUB, MULT, nexpVal_def])
);
\end{lstlisting}

\subsection{Session Transcript}
\label{sec:session-transcript-1}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

> # # # # # # # # val Add_0 =
   |- !(f :nexp). nexpVal (Add (Num (0 :num)) f) = nexpVal f:
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}

\section{Proof of \emph{Add_SYM}}


\subsection{Code for Proving \emph{Add_SYM}}
\begin{lstlisting}[frame=trBL]
val Add_SYM =
TAC_PROOF(
([], ``!f1 f2. nexpVal (Add f1 f2) = nexpVal (Add f2 f1)``),
REWRITE_TAC [ADD, nexpVal_def] THEN
REWRITE_TAC [Once ADD_COMM]
);
\end{lstlisting}

\subsection{Session Transcript}
\label{sec:session-transcript-1}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

> # # # # # val Add_SYM =
   |- !(f1 :nexp) (f2 :nexp). nexpVal (Add f1 f2) = nexpVal (Add f2 f1):
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}

\section{Proof of \emph{Sub_0}}


\subsection{Code for Proving \emph{Sub_0}}
\begin{lstlisting}[frame=trBL]
val Sub_0 =
TAC_PROOF(
([], ``!f. (nexpVal (Sub (Num 0) f ) = 0)/\(nexpVal (Sub f (Num 0)) = nexpVal f)``),
REWRITE_TAC [SUB, nexpVal_def] THEN
REWRITE_TAC [SUB_0]
);
\end{lstlisting}

\subsection{Session Transcript}
\label{sec:session-transcript-1}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

> # # # # # val Sub_0 =
   |- !(f :nexp).
     (nexpVal (Sub (Num (0 :num)) f) = (0 :num)) /\
     (nexpVal (Sub f (Num (0 :num))) = nexpVal f):
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}

\section{Proof of \emph{Mult_ASSOC}}


\subsection{Code for Proving \emph{Mult_ASSOC}}
\begin{lstlisting}[frame=trBL]
val Mult_ASSOC =
TAC_PROOF(
([], ``!f1 f2 f3. nexpVal (Mult f1 (Mult f2 f3)) = nexpVal (Mult (Mult f1 f2) f3)``),
REWRITE_TAC [nexpVal_def, MULT, MULT_ASSOC]
);
\end{lstlisting}

\subsection{Session Transcript}
\label{sec:session-transcript-1}

\setcounter{sessioncount}{0}
\begin{session}
  \begin{scriptsize}
\begin{verbatim}

> # # # # val Mult_ASSOC =
   |- !(f1 :nexp) (f2 :nexp) (f3 :nexp).
     nexpVal (Mult f1 (Mult f2 f3)) = nexpVal (Mult (Mult f1 f2) f3):
   thm
\end{verbatim}
  \end{scriptsize}
\end{session}




%% ------------------------------------------
%% Change to letters for appendix
%% ------------------------------------------

%% ------------------------------------------
%% this restarts the section numbering
%% ------------------------------------------
\appendix{} 


%% ------------------------------------------
% label using capital letters
%% ------------------------------------------
\renewcommand{\thechapter}{\Alph{chapter}} 

\chapter{Source Code for exTypeScript.sml}
\label{cha:source-code-sample}

The following code is from \emph{exTypeScript.sml}, which is located
in directory "../HOL/" 
\lstinputlisting{../HOL/exTypeScript.sml}

\chapter{Source Code for nexpScript.sml}
\label{cha:source-code-sample}

The following code is from \emph{nexpScript.sml}, which is located
in directory "../HOL/"
\lstinputlisting{../HOL/nexpScript.sml}

\end{document}
